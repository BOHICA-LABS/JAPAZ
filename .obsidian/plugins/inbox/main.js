/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends2 = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest2 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn2 = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t, e) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return t2 === void 0;
      } }, g = "en", D = {};
      D[g] = M;
      var p = function(t2) {
        return t2 instanceof _;
      }, S = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if (typeof e2 == "string") {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, w = function(t2, e2) {
        if (p(t2))
          return t2.clone();
        var n2 = typeof e2 == "object" ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, O = v;
      O.l = S, O.i = p, O.w = function(t2, e2) {
        return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = S(t2.locale, null, true), this.parse(t2);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (e2 === null)
              return new Date(NaN);
            if (O.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if (typeof e2 == "string" && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = w(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return w(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < w(t2);
        }, m2.$g = function(t2, e2, n2) {
          return O.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t2), l2 = function(t3, e3) {
            var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (h2) {
            case c:
              return r2 ? l2(1, 0) : l2(31, 11);
            case f:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === f || o2 === c) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[O.p(t2)]();
        }, m2.add = function(r2, h2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = O.p(h2), y2 = function(t2) {
            var e2 = w(l2);
            return O.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === f)
            return this.set(f, this.$M + r2);
          if ($2 === c)
            return this.set(c, this.$y + r2);
          if ($2 === a)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, c2 = function(t3) {
            return O.s(s2 % 12 || 12, t3, "0");
          }, d2 = n2.meridiem || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          }, $2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n2.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
          return r2.replace(y, function(t3, e3) {
            return e3 || $2[t3] || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, v2 = this - M3, g2 = O.m(this, M3);
          return g2 = ($2 = {}, $2[c] = g2 / 12, $2[f] = g2, $2[h] = g2 / 3, $2[o] = (v2 - m3) / 6048e5, $2[a] = (v2 - m3) / 864e5, $2[u] = v2 / n, $2[s] = v2 / e, $2[i] = v2 / t, $2)[y2] || v2, l2 ? g2 : O.a(g2);
        }, m2.daysInMonth = function() {
          return this.endOf(f).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = S(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), T = _.prototype;
      return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
        T[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), w.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, w), t2.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
        return w(1e3 * t2);
      }, w.en = D[g], w.Ls = D, w.p = {}, w;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => InboxPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/markdown-file-info-helpers.ts
function getValueFromMarkdownFileInfo(fileInfo) {
  var _a;
  if (fileInfo.editor) {
    return fileInfo.editor.getValue();
  }
  return (_a = fileInfo.data) != null ? _a : "";
}

// src/Notice.ts
var import_obsidian = require("obsidian");
var DEFAULT_NOTICE_TIMEOUT_SECONDS = 5;
var InfoNotice = class extends import_obsidian.Notice {
  constructor(message, timeout = DEFAULT_NOTICE_TIMEOUT_SECONDS) {
    super(`Inbox
${message}`, timeout * 1e3);
    console.info(`obsidian-inbox: ${message}`);
  }
};
var ErrorNotice = class extends import_obsidian.Notice {
  constructor(message, timeout = DEFAULT_NOTICE_TIMEOUT_SECONDS) {
    super(`Inbox
${message}`, timeout * 1e3);
    console.error(`obsidian-inbox: ${message}`);
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  inboxNotePath: "",
  compareType: "compareToLastTracked",
  inboxNoteBaseContents: "",
  inboxNoteContents: "",
  noticeDurationSeconds: null,
  walkthroughStatus: "unstarted"
};
function migrateSettings(settings) {
  if (settings.inboxNotePath && !settings.inboxNotePath.endsWith(".md")) {
    settings.inboxNotePath += ".md";
  }
  return settings;
}

// src/settings-tab/SettingsTab.ts
var import_obsidian3 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store2, ...callbacks) {
  if (store2 == null) {
    return noop;
  }
  const unsub = store2.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store2, callback) {
  component.$$.on_destroy.push(subscribe(store2, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store2, ret, value) {
  store2.set(value);
  return ret;
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance12, create_fragment12, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance12 ? instance12(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment12 ? create_fragment12($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
} = import_tslib.default;

// node_modules/obsidian-svelte/Icon/useIcon.js
var import_obsidian2 = require("obsidian");

// node_modules/obsidian-svelte/Input/Input.svelte
function add_css(target) {
  append_styles(target, "svelte-su9mt0", ".embed.svelte-su9mt0{all:unset;box-sizing:border-box;padding:6px;font-weight:400;font-family:var(--font-default);color:var(--text-normal)}.embed.svelte-su9mt0:focus{box-shadow:none}.noPadding.svelte-su9mt0{padding:0}.error.svelte-su9mt0{border-color:var(--background-modifier-error)}.error.svelte-su9mt0:hover{border-color:var(--background-modifier-error-hover)}.error.svelte-su9mt0:focus{box-shadow:0 0 0 2px var(--background-modifier-error);border-color:var(--background-modifier-error)}small.svelte-su9mt0{margin-top:var(--size-4-1);font-size:var(--font-ui-smaller);color:var(--text-muted);display:block}.errorText.svelte-su9mt0{color:var(--text-error)}");
}
function create_if_block(ctx) {
  let small;
  let t;
  return {
    c() {
      small = element("small");
      t = text(ctx[9]);
      attr(small, "class", "svelte-su9mt0");
      toggle_class(small, "errorText", ctx[6]);
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t);
    },
    p(ctx2, dirty) {
      if (dirty & 512)
        set_data(t, ctx2[9]);
      if (dirty & 64) {
        toggle_class(small, "errorText", ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment(ctx) {
  let div;
  let input;
  let input_style_value;
  let t;
  let div_style_value;
  let mounted;
  let dispose;
  let if_block = !!ctx[9] && create_if_block(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      input.value = ctx[2];
      attr(input, "type", ctx[1]);
      attr(input, "placeholder", ctx[4]);
      input.readOnly = ctx[3];
      attr(input, "style", input_style_value = `width: ${ctx[5]}`);
      attr(input, "class", "svelte-su9mt0");
      toggle_class(input, "error", ctx[6]);
      toggle_class(input, "embed", ctx[7]);
      toggle_class(input, "noPadding", ctx[8]);
      attr(div, "style", div_style_value = `width: ${ctx[5]}`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      ctx[16](input);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[11]),
          listen(input, "focus", ctx[12]),
          listen(input, "blur", ctx[13]),
          listen(input, "keydown", ctx[14]),
          listen(input, "keyup", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && input.value !== ctx2[2]) {
        input.value = ctx2[2];
      }
      if (dirty & 2) {
        attr(input, "type", ctx2[1]);
      }
      if (dirty & 16) {
        attr(input, "placeholder", ctx2[4]);
      }
      if (dirty & 8) {
        input.readOnly = ctx2[3];
      }
      if (dirty & 32 && input_style_value !== (input_style_value = `width: ${ctx2[5]}`)) {
        attr(input, "style", input_style_value);
      }
      if (dirty & 64) {
        toggle_class(input, "error", ctx2[6]);
      }
      if (dirty & 128) {
        toggle_class(input, "embed", ctx2[7]);
      }
      if (dirty & 256) {
        toggle_class(input, "noPadding", ctx2[8]);
      }
      if (!!ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32 && div_style_value !== (div_style_value = `width: ${ctx2[5]}`)) {
        attr(div, "style", div_style_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[16](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { type } = $$props;
  let { value } = $$props;
  let { ref = null } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error = false } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { helperText = "" } = $$props;
  const dispatch = createEventDispatcher();
  onMount(() => {
    if (autoFocus && ref) {
      ref.focus();
    }
  });
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(4, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(10, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error = $$props2.error);
    if ("embed" in $$props2)
      $$invalidate(7, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(8, noPadding = $$props2.noPadding);
    if ("helperText" in $$props2)
      $$invalidate(9, helperText = $$props2.helperText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        dispatch("input", value);
    }
  };
  return [
    ref,
    type,
    value,
    readonly,
    placeholder,
    width,
    error,
    embed,
    noPadding,
    helperText,
    autoFocus,
    input_handler,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler,
    input_binding
  ];
}
var Input = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      type: 1,
      value: 2,
      ref: 0,
      readonly: 3,
      placeholder: 4,
      autoFocus: 10,
      width: 5,
      error: 6,
      embed: 7,
      noPadding: 8,
      helperText: 9
    }, add_css);
  }
};
var Input_default = Input;

// node_modules/obsidian-svelte/Input/TextInput.svelte
function create_fragment2(ctx) {
  let input;
  let updating_ref;
  let updating_value;
  let current;
  function input_ref_binding(value) {
    ctx[11](value);
  }
  function input_value_binding(value) {
    ctx[12](value);
  }
  let input_props = {
    type: "text",
    readonly: ctx[2],
    noPadding: ctx[9],
    placeholder: ctx[3],
    autoFocus: ctx[4],
    width: ctx[5],
    embed: ctx[8],
    error: ctx[6],
    helperText: ctx[7]
  };
  if (ctx[1] !== void 0) {
    input_props.ref = ctx[1];
  }
  if (ctx[0] !== void 0) {
    input_props.value = ctx[0];
  }
  input = new Input_default({ props: input_props });
  binding_callbacks.push(() => bind(input, "ref", input_ref_binding));
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  input.$on("input", ctx[10]);
  input.$on("focus", ctx[13]);
  input.$on("blur", ctx[14]);
  input.$on("keydown", ctx[15]);
  input.$on("keyup", ctx[16]);
  return {
    c() {
      create_component(input.$$.fragment);
    },
    m(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const input_changes = {};
      if (dirty & 4)
        input_changes.readonly = ctx2[2];
      if (dirty & 512)
        input_changes.noPadding = ctx2[9];
      if (dirty & 8)
        input_changes.placeholder = ctx2[3];
      if (dirty & 16)
        input_changes.autoFocus = ctx2[4];
      if (dirty & 32)
        input_changes.width = ctx2[5];
      if (dirty & 256)
        input_changes.embed = ctx2[8];
      if (dirty & 64)
        input_changes.error = ctx2[6];
      if (dirty & 128)
        input_changes.helperText = ctx2[7];
      if (!updating_ref && dirty & 2) {
        updating_ref = true;
        input_changes.ref = ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & 1) {
        updating_value = true;
        input_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(input, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error = false } = $$props;
  let { helperText = "" } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.value);
    }
  }
  function input_ref_binding(value2) {
    ref = value2;
    $$invalidate(1, ref);
  }
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(4, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error = $$props2.error);
    if ("helperText" in $$props2)
      $$invalidate(7, helperText = $$props2.helperText);
    if ("embed" in $$props2)
      $$invalidate(8, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(9, noPadding = $$props2.noPadding);
    if ("ref" in $$props2)
      $$invalidate(1, ref = $$props2.ref);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("input", value);
    }
  };
  return [
    value,
    ref,
    readonly,
    placeholder,
    autoFocus,
    width,
    error,
    helperText,
    embed,
    noPadding,
    handleInput,
    input_ref_binding,
    input_value_binding,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler
  ];
}
var TextInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      value: 0,
      readonly: 2,
      placeholder: 3,
      autoFocus: 4,
      width: 5,
      error: 6,
      helperText: 7,
      embed: 8,
      noPadding: 9,
      ref: 1
    });
  }
};
var TextInput_default = TextInput;

// node_modules/obsidian-svelte/Input/NumberInput.svelte
function create_fragment3(ctx) {
  let input;
  let updating_ref;
  let updating_value;
  let current;
  function input_ref_binding(value) {
    ctx[11](value);
  }
  function input_value_binding(value) {
    ctx[12](value);
  }
  let input_props = {
    type: "number",
    readonly: ctx[2],
    placeholder: ctx[3],
    autoFocus: ctx[4],
    width: ctx[5],
    embed: ctx[7],
    noPadding: ctx[8],
    error: ctx[6],
    helperText: ctx[9]
  };
  if (ctx[1] !== void 0) {
    input_props.ref = ctx[1];
  }
  if (ctx[0] !== void 0) {
    input_props.value = ctx[0];
  }
  input = new Input_default({ props: input_props });
  binding_callbacks.push(() => bind(input, "ref", input_ref_binding));
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  input.$on("input", ctx[10]);
  input.$on("focus", ctx[13]);
  input.$on("blur", ctx[14]);
  input.$on("keydown", ctx[15]);
  return {
    c() {
      create_component(input.$$.fragment);
    },
    m(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const input_changes = {};
      if (dirty & 4)
        input_changes.readonly = ctx2[2];
      if (dirty & 8)
        input_changes.placeholder = ctx2[3];
      if (dirty & 16)
        input_changes.autoFocus = ctx2[4];
      if (dirty & 32)
        input_changes.width = ctx2[5];
      if (dirty & 128)
        input_changes.embed = ctx2[7];
      if (dirty & 256)
        input_changes.noPadding = ctx2[8];
      if (dirty & 64)
        input_changes.error = ctx2[6];
      if (dirty & 512)
        input_changes.helperText = ctx2[9];
      if (!updating_ref && dirty & 2) {
        updating_ref = true;
        input_changes.ref = ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & 1) {
        updating_value = true;
        input_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(input, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { ref = null } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error = false } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { helperText = "" } = $$props;
  const dispatch = createEventDispatcher();
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.valueAsNumber);
    }
  }
  function input_ref_binding(value2) {
    ref = value2;
    $$invalidate(1, ref);
  }
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("ref" in $$props2)
      $$invalidate(1, ref = $$props2.ref);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(4, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error = $$props2.error);
    if ("embed" in $$props2)
      $$invalidate(7, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(8, noPadding = $$props2.noPadding);
    if ("helperText" in $$props2)
      $$invalidate(9, helperText = $$props2.helperText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("input", value);
    }
  };
  return [
    value,
    ref,
    readonly,
    placeholder,
    autoFocus,
    width,
    error,
    embed,
    noPadding,
    helperText,
    handleInput,
    input_ref_binding,
    input_value_binding,
    focus_handler,
    blur_handler,
    keydown_handler
  ];
}
var NumberInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      value: 0,
      ref: 1,
      readonly: 2,
      placeholder: 3,
      autoFocus: 4,
      width: 5,
      error: 6,
      embed: 7,
      noPadding: 8,
      helperText: 9
    });
  }
};
var NumberInput_default = NumberInput;

// node_modules/obsidian-svelte/Button/Button.svelte
function add_css2(target) {
  append_styles(target, "svelte-12xcpmj", "button.svelte-12xcpmj{gap:var(--size-4-1)}.mod-plain.svelte-12xcpmj{background:none;box-shadow:none;border:none;color:var(--text-muted)}.mod-plain.svelte-12xcpmj:hover{color:var(--text-normal)}.disabled.svelte-12xcpmj{opacity:0.6}");
}
function create_fragment4(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "aria-label", ctx[3]);
      button.disabled = ctx[2];
      attr(button, "class", "svelte-12xcpmj");
      toggle_class(button, "mod-cta", ctx[1] === "primary");
      toggle_class(button, "mod-warning", ctx[1] === "destructive");
      toggle_class(button, "mod-plain", ctx[1] === "plain");
      toggle_class(button, "disabled", ctx[2]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      ctx[7](button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[4], !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null), null);
        }
      }
      if (!current || dirty & 8) {
        attr(button, "aria-label", ctx2[3]);
      }
      if (!current || dirty & 4) {
        button.disabled = ctx2[2];
      }
      if (!current || dirty & 2) {
        toggle_class(button, "mod-cta", ctx2[1] === "primary");
      }
      if (!current || dirty & 2) {
        toggle_class(button, "mod-warning", ctx2[1] === "destructive");
      }
      if (!current || dirty & 2) {
        toggle_class(button, "mod-plain", ctx2[1] === "plain");
      }
      if (!current || dirty & 4) {
        toggle_class(button, "disabled", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant = "default" } = $$props;
  let { disabled = false } = $$props;
  let { tooltip = "" } = $$props;
  let { ref = null } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(1, variant = $$props2.variant);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("tooltip" in $$props2)
      $$invalidate(3, tooltip = $$props2.tooltip);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [ref, variant, disabled, tooltip, $$scope, slots, click_handler, button_binding];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      variant: 1,
      disabled: 2,
      tooltip: 3,
      ref: 0
    }, add_css2);
  }
};
var Button_default = Button;

// node_modules/obsidian-svelte/DateInput/DateInput.svelte
var import_dayjs = __toESM(require_dayjs_min(), 1);

// node_modules/obsidian-svelte/Select/SelectItem.svelte
function create_fragment5(ctx) {
  let option;
  let t_value = (ctx[0] || ctx[1]) + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[1];
      option.value = option.__value;
      option.disabled = ctx[2];
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & 3 && t_value !== (t_value = (ctx2[0] || ctx2[1]) + ""))
        set_data(t, t_value);
      if (dirty & 2) {
        option.__value = ctx2[1];
        option.value = option.__value;
      }
      if (dirty & 4) {
        option.disabled = ctx2[2];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { text: text2 } = $$props;
  let { value } = $$props;
  let { disabled = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  return [text2, value, disabled];
}
var SelectItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { text: 0, value: 1, disabled: 2 });
  }
};
var SelectItem_default = SelectItem;

// node_modules/obsidian-svelte/Select/Select.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_if_block_1(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      text: ctx[2],
      value: "",
      disabled: true
    }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 4)
        selectitem_changes.text = ctx2[2];
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_if_block2(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: { text: ctx[2], value: "" }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 4)
        selectitem_changes.text = ctx2[2];
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_each_block(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      text: ctx[7].label,
      value: ctx[7].value
    }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 1)
        selectitem_changes.text = ctx2[7].label;
      if (dirty & 1)
        selectitem_changes.value = ctx2[7].value;
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_fragment6(ctx) {
  let select;
  let if_block0_anchor;
  let if_block1_anchor;
  let select_disabled_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[0].length && ctx[2] && create_if_block_1(ctx);
  let if_block1 = ctx[3] && create_if_block2(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      select = element("select");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      select.disabled = select_disabled_value = ctx[4] || !ctx[0].length && !!ctx[2];
      attr(select, "class", "dropdown");
    },
    m(target, anchor) {
      insert(target, select, anchor);
      if (if_block0)
        if_block0.m(select, null);
      append(select, if_block0_anchor);
      if (if_block1)
        if_block1.m(select, null);
      append(select, if_block1_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[1]);
      current = true;
      if (!mounted) {
        dispose = listen(select, "change", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!ctx2[0].length && ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 5) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(select, if_block0_anchor);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(select, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty & 1) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(select, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 21 && select_disabled_value !== (select_disabled_value = ctx2[4] || !ctx2[0].length && !!ctx2[2])) {
        select.disabled = select_disabled_value;
      }
      if (!current || dirty & 2) {
        select_option(select, ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(select);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { options } = $$props;
  let { value } = $$props;
  let { placeholder = "" } = $$props;
  let { allowEmpty = false } = $$props;
  let { disabled = false } = $$props;
  const dispatch = createEventDispatcher();
  function handleChange(event) {
    if (event.currentTarget instanceof HTMLSelectElement) {
      dispatch("change", event.currentTarget.value);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(0, options = $$props2.options);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("placeholder" in $$props2)
      $$invalidate(2, placeholder = $$props2.placeholder);
    if ("allowEmpty" in $$props2)
      $$invalidate(3, allowEmpty = $$props2.allowEmpty);
    if ("disabled" in $$props2)
      $$invalidate(4, disabled = $$props2.disabled);
  };
  return [options, value, placeholder, allowEmpty, disabled, handleChange];
}
var Select = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      options: 0,
      value: 1,
      placeholder: 2,
      allowEmpty: 3,
      disabled: 4
    });
  }
};
var Select_default = Select;

// node_modules/obsidian-svelte/Setting/SettingItem.svelte
function add_css3(target) {
  append_styles(target, "svelte-17mpvkc", ".vertical.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1)}.vertical-control.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1);width:100%}");
}
function create_fragment7(ctx) {
  var _a, _b;
  let div4;
  let div2;
  let div0;
  let t0_value = ((_a = ctx[0]) != null ? _a : "") + "";
  let t0;
  let t1;
  let div1;
  let t2_value = ((_b = ctx[1]) != null ? _b : "") + "";
  let t2;
  let t3;
  let div3;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(div3, "class", "setting-item-control svelte-17mpvkc");
      toggle_class(div3, "vertical-control", ctx[2]);
      attr(div4, "class", "setting-item svelte-17mpvkc");
      toggle_class(div4, "vertical", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ((_a2 = ctx2[0]) != null ? _a2 : "") + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 2) && t2_value !== (t2_value = ((_b2 = ctx2[1]) != null ? _b2 : "") + ""))
        set_data(t2, t2_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 4) {
        toggle_class(div3, "vertical-control", ctx2[2]);
      }
      if (!current || dirty & 4) {
        toggle_class(div4, "vertical", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = void 0 } = $$props;
  let { description = void 0 } = $$props;
  let { vertical = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("vertical" in $$props2)
      $$invalidate(2, vertical = $$props2.vertical);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [name, description, vertical, $$scope, slots];
}
var SettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { name: 0, description: 1, vertical: 2 }, add_css3);
  }
};
var SettingItem_default = SettingItem;

// node_modules/obsidian-svelte/TextArea/TextArea.svelte
function add_css4(target) {
  append_styles(target, "svelte-1yhxf9x", "textarea.svelte-1yhxf9x{font-family:var(--font-monospace-default)}");
}
function create_fragment8(ctx) {
  let textarea;
  let textarea_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "rows", ctx[1]);
      attr(textarea, "style", textarea_style_value = `width: ${ctx[2]}`);
      attr(textarea, "placeholder", ctx[3]);
      attr(textarea, "class", "svelte-1yhxf9x");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(textarea, ctx[0]);
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        attr(textarea, "rows", ctx2[1]);
      }
      if (dirty & 4 && textarea_style_value !== (textarea_style_value = `width: ${ctx2[2]}`)) {
        attr(textarea, "style", textarea_style_value);
      }
      if (dirty & 8) {
        attr(textarea, "placeholder", ctx2[3]);
      }
      if (dirty & 1) {
        set_input_value(textarea, ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { rows } = $$props;
  let { width = "auto" } = $$props;
  let { placeholder = "" } = $$props;
  const dispatch = createEventDispatcher();
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("rows" in $$props2)
      $$invalidate(1, rows = $$props2.rows);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("input", value);
    }
  };
  return [value, rows, width, placeholder, textarea_input_handler];
}
var TextArea = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      value: 0,
      rows: 1,
      width: 2,
      placeholder: 3
    }, add_css4);
  }
};
var TextArea_default = TextArea;

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store2, i) => subscribe(store2, (value) => {
      values[i] = value;
      pending &= ~(1 << i);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}

// src/walkthrough/WalkthroughStatus.ts
var WALKTHROUGH_STATUS_OPTIONS = [
  "unstarted",
  "setCompareType",
  "runSetInboxNoteCommand",
  "restartObsidian",
  "completed"
];

// src/store.ts
function createStore() {
  const { subscribe: subscribe2, set, update: update2 } = writable();
  const walkthrough = {
    next() {
      update2((settings) => {
        const currentStepIndex = WALKTHROUGH_STATUS_OPTIONS.indexOf(settings.walkthroughStatus);
        if (currentStepIndex + 1 < WALKTHROUGH_STATUS_OPTIONS.length) {
          const nextStep = WALKTHROUGH_STATUS_OPTIONS[currentStepIndex + 1];
          settings.walkthroughStatus = nextStep;
        }
        return settings;
      });
    },
    back() {
      update2((settings) => {
        const currentStepIndex = WALKTHROUGH_STATUS_OPTIONS.indexOf(settings.walkthroughStatus);
        if (currentStepIndex > 0) {
          const nextStep = WALKTHROUGH_STATUS_OPTIONS[currentStepIndex - 1];
          settings.walkthroughStatus = nextStep;
        }
        return settings;
      });
    },
    complete() {
      update2((settings) => {
        settings.walkthroughStatus = "completed";
        return settings;
      });
    },
    reset() {
      update2((settings) => {
        settings.walkthroughStatus = "setCompareType";
        return settings;
      });
    }
  };
  return {
    subscribe: subscribe2,
    set,
    walkthrough
  };
}
var store = createStore();
var store_default = store;
var currentWalkthroughStep = derived(store, ($settings) => {
  if ($settings == null ? void 0 : $settings.walkthroughStatus) {
    return WALKTHROUGH_STATUS_OPTIONS.indexOf($settings.walkthroughStatus);
  }
  return 0;
});

// src/components/CompareTypeSelect.svelte
function create_fragment9(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      options: ctx[1],
      value: ctx[0]
    }
  });
  select.$on("change", ctx[2]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const select_changes = {};
      if (dirty & 1)
        select_changes.value = ctx2[0];
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { value } = $$props;
  const options = [
    {
      label: "Compare to last tracked",
      value: "compareToLastTracked"
    },
    {
      label: "Compare to base",
      value: "compareToBase"
    }
  ];
  const dispatch = createEventDispatcher();
  function handleChange({ detail }) {
    if (detail === "compareToBase" || detail === "compareToLastTracked") {
      dispatch("change", detail);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value, options, handleChange];
}
var CompareTypeSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, { value: 0 });
  }
};
var CompareTypeSelect_default = CompareTypeSelect;

// src/settings-tab/SettingsTab.svelte
function add_css5(target) {
  append_styles(target, "svelte-2e2o1w", ".hidden.svelte-2e2o1w{display:none}");
}
function create_default_slot_5(ctx) {
  let t;
  return {
    c() {
      t = text("Start");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_4(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[1]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 128) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      placeholder: "Inbox",
      value: ctx[0].inboxNotePath
    }
  });
  textinput.$on("input", ctx[3]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 1)
        textinput_changes.value = ctx2[0].inboxNotePath;
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let comparetypeselect;
  let current;
  comparetypeselect = new CompareTypeSelect_default({
    props: { value: ctx[0].compareType }
  });
  comparetypeselect.$on("change", ctx[4]);
  return {
    c() {
      create_component(comparetypeselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(comparetypeselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const comparetypeselect_changes = {};
      if (dirty & 1)
        comparetypeselect_changes.value = ctx2[0].compareType;
      comparetypeselect.$set(comparetypeselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(comparetypeselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(comparetypeselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(comparetypeselect, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let textarea;
  let current;
  textarea = new TextArea_default({
    props: {
      placeholder: "# Inbox",
      value: ctx[0].inboxNoteBaseContents,
      rows: 3
    }
  });
  textarea.$on("input", ctx[5]);
  return {
    c() {
      create_component(textarea.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textarea, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textarea_changes = {};
      if (dirty & 1)
        textarea_changes.value = ctx2[0].inboxNoteBaseContents;
      textarea.$set(textarea_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textarea.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textarea.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textarea, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let numberinput;
  let current;
  numberinput = new NumberInput_default({
    props: {
      placeholder: "0",
      value: ctx[0].noticeDurationSeconds
    }
  });
  numberinput.$on("input", ctx[6]);
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & 1)
        numberinput_changes.value = ctx2[0].noticeDurationSeconds;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_fragment10(ctx) {
  let h20;
  let t1;
  let settingitem0;
  let t2;
  let h21;
  let t4;
  let settingitem1;
  let t5;
  let settingitem2;
  let t6;
  let div;
  let settingitem3;
  let div_class_value;
  let t7;
  let settingitem4;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: "Start walkthrough",
      description: "This will open a pane in the sidebar to guide you through how to use this plugin.",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: "Inbox path",
      description: "Path for inbox note.",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  settingitem2 = new SettingItem_default({
    props: {
      name: "Compare type",
      description: "What to compare the inbox note contents to when deciding whether or not to notify. 'Compare to last tracked' will compare to a snapshot from when Obsidian was last closed. 'Compare to base' will compare to a base contents that you define.",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  settingitem3 = new SettingItem_default({
    props: {
      name: "Inbox base contents",
      description: "If note content matches this exactly, then you will not be notified.",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  settingitem4 = new SettingItem_default({
    props: {
      name: "Inbox notice duration",
      description: "Duration to show Notice when there is data to process, in seconds. Set to 0 for infinite duration. Clear to use global default Notice duration.",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      h20 = element("h2");
      h20.textContent = "Walkthrough";
      t1 = space();
      create_component(settingitem0.$$.fragment);
      t2 = space();
      h21 = element("h2");
      h21.textContent = "Inbox Settings";
      t4 = space();
      create_component(settingitem1.$$.fragment);
      t5 = space();
      create_component(settingitem2.$$.fragment);
      t6 = space();
      div = element("div");
      create_component(settingitem3.$$.fragment);
      t7 = space();
      create_component(settingitem4.$$.fragment);
      attr(div, "class", div_class_value = null_to_empty(ctx[0].compareType !== "compareToBase" ? "hidden" : "") + " svelte-2e2o1w");
    },
    m(target, anchor) {
      insert(target, h20, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem0, target, anchor);
      insert(target, t2, anchor);
      insert(target, h21, anchor);
      insert(target, t4, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t5, anchor);
      mount_component(settingitem2, target, anchor);
      insert(target, t6, anchor);
      insert(target, div, anchor);
      mount_component(settingitem3, div, null);
      insert(target, t7, anchor);
      mount_component(settingitem4, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingitem0_changes = {};
      if (dirty & 128) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & 129) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      const settingitem2_changes = {};
      if (dirty & 129) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
      const settingitem3_changes = {};
      if (dirty & 129) {
        settingitem3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem3.$set(settingitem3_changes);
      if (!current || dirty & 1 && div_class_value !== (div_class_value = null_to_empty(ctx2[0].compareType !== "compareToBase" ? "hidden" : "") + " svelte-2e2o1w")) {
        attr(div, "class", div_class_value);
      }
      const settingitem4_changes = {};
      if (dirty & 129) {
        settingitem4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem4.$set(settingitem4_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitem2.$$.fragment, local);
      transition_in(settingitem3.$$.fragment, local);
      transition_in(settingitem4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitem2.$$.fragment, local);
      transition_out(settingitem3.$$.fragment, local);
      transition_out(settingitem4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h20);
      if (detaching)
        detach(t1);
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(h21);
      if (detaching)
        detach(t4);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t5);
      destroy_component(settingitem2, detaching);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(div);
      destroy_component(settingitem3);
      if (detaching)
        detach(t7);
      destroy_component(settingitem4, detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store_default, ($$value) => $$invalidate(0, $store = $$value));
  let { activateWalkthroughView } = $$props;
  function startWalkthrough() {
    return __awaiter(this, void 0, void 0, function* () {
      store_default.walkthrough.reset();
      activateWalkthroughView();
    });
  }
  const input_handler = ({ detail }) => {
    set_store_value(store_default, $store.inboxNotePath = detail, $store);
  };
  const change_handler = ({ detail }) => {
    set_store_value(store_default, $store.compareType = detail, $store);
  };
  const input_handler_1 = ({ detail }) => {
    set_store_value(store_default, $store.inboxNoteBaseContents = detail, $store);
  };
  const input_handler_2 = ({ detail }) => {
    set_store_value(store_default, $store.noticeDurationSeconds = detail, $store);
  };
  $$self.$$set = ($$props2) => {
    if ("activateWalkthroughView" in $$props2)
      $$invalidate(2, activateWalkthroughView = $$props2.activateWalkthroughView);
  };
  return [
    $store,
    startWalkthrough,
    activateWalkthroughView,
    input_handler,
    change_handler,
    input_handler_1,
    input_handler_2
  ];
}
var SettingsTab = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, { activateWalkthroughView: 2 }, add_css5);
  }
};
var SettingsTab_default = SettingsTab;

// src/settings-tab/SettingsTab.ts
var SettingsTab2 = class extends import_obsidian3.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.component = new SettingsTab_default({
      target: containerEl,
      props: {
        activateWalkthroughView: () => {
          this.plugin.ensureWalkthroughViewExists(true);
          this.app.setting.close();
        }
      }
    });
  }
};

// src/walkthrough/WalkthroughView.ts
var import_obsidian4 = require("obsidian");

// src/walkthrough/WalkthroughView.svelte
function add_css6(target) {
  append_styles(target, "svelte-ys9x1z", ".flex.svelte-ys9x1z{display:flex}.ml-auto.svelte-ys9x1z{margin-left:auto}");
}
function create_if_block_8(ctx) {
  let p0;
  let t1;
  let p1;
  return {
    c() {
      p0 = element("p");
      p0.textContent = "You've completed the walkthrough!";
      t1 = space();
      p1 = element("p");
      p1.textContent = "Feel free to close the walkthrough, or go back if you missed something!\n		You can always re-open this walkthrough in the plugin settings.";
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      insert(target, t1, anchor);
      insert(target, p1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(p1);
    }
  };
}
function create_if_block_5(ctx) {
  let p0;
  let t1;
  let t2;
  let t3;
  let p1;
  let if_block0 = ctx[1].compareType === "compareToBase" && create_if_block_7(ctx);
  let if_block1 = ctx[1].compareType === "compareToLastTracked" && create_if_block_6(ctx);
  return {
    c() {
      p0 = element("p");
      p0.textContent = "Alright, let's verify that this is working.";
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      p1 = element("p");
      p1.textContent = 'Click the "Next" button below to continue.';
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      insert(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t3, anchor);
      insert(target, p1, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[1].compareType === "compareToBase") {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_7(ctx2);
          if_block0.c();
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1].compareType === "compareToLastTracked") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_6(ctx2);
          if_block1.c();
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t1);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(p1);
    }
  };
}
function create_if_block_3(ctx) {
  let p;
  let t1;
  let ol;
  let li0;
  let t3;
  let t4;
  let li1;
  let if_block = ctx[1].compareType === "compareToBase" && create_if_block_4(ctx);
  return {
    c() {
      p = element("p");
      p.textContent = "Let's setup which note will be your inbox note.";
      t1 = space();
      ol = element("ol");
      li0 = element("li");
      li0.textContent = 'Open the note that you want to be your "Inbox" note. It can be\n			called whatever you want, and can be anywhere in your vault.';
      t3 = space();
      if (if_block)
        if_block.c();
      t4 = space();
      li1 = element("li");
      li1.innerHTML = `Open the command palette with the keyboard shortcut
			<code>cmd p</code>
			(<code>ctrl p</code> on Windows) and run the &quot;Set inbox note&quot; command.`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
      insert(target, t1, anchor);
      insert(target, ol, anchor);
      append(ol, li0);
      append(ol, t3);
      if (if_block)
        if_block.m(ol, null);
      append(ol, t4);
      append(ol, li1);
    },
    p(ctx2, dirty) {
      if (ctx2[1].compareType === "compareToBase") {
        if (if_block) {
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(ol, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(ol);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_2(ctx) {
  let p0;
  let t1;
  let p1;
  let t3;
  let comparetypeselect;
  let t4;
  let p2;
  let t6;
  let p3;
  let current;
  comparetypeselect = new CompareTypeSelect_default({
    props: { value: ctx[1].compareType }
  });
  comparetypeselect.$on("change", ctx[4]);
  return {
    c() {
      p0 = element("p");
      p0.textContent = "Looks like you haven't setup Obsidian Inbox yet! Let's get started!";
      t1 = space();
      p1 = element("p");
      p1.textContent = "What would you like to compare your inbox note's contents to when\n		deciding whether or not to show a notification on startup?";
      t3 = space();
      create_component(comparetypeselect.$$.fragment);
      t4 = space();
      p2 = element("p");
      p2.textContent = "'Compare to last tracked' will compare to a snapshot from when Obsidian\n		was last closed. This is the default, and is most commonly used when you\n		want to know if a note was changes externally outside of Obsidian.";
      t6 = space();
      p3 = element("p");
      p3.textContent = "'Compare to base' will compare to a base contents that you define. This\n		is used for when you want to know if there's anything in your inbox\n		note, even if there haven't been any changes to your note since your\n		last startup.";
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      insert(target, t1, anchor);
      insert(target, p1, anchor);
      insert(target, t3, anchor);
      mount_component(comparetypeselect, target, anchor);
      insert(target, t4, anchor);
      insert(target, p2, anchor);
      insert(target, t6, anchor);
      insert(target, p3, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const comparetypeselect_changes = {};
      if (dirty & 2)
        comparetypeselect_changes.value = ctx2[1].compareType;
      comparetypeselect.$set(comparetypeselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(comparetypeselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(comparetypeselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t3);
      destroy_component(comparetypeselect, detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(p3);
    }
  };
}
function create_if_block_7(ctx) {
  let ol;
  return {
    c() {
      ol = element("ol");
      ol.innerHTML = `<li>Restart Obsidian. You should <i>not</i> get a notification, since
				you haven&#39;t added anything to your &quot;Inbox&quot; note aside from anything
				added before you ran the &quot;Set inbox note&quot; command.</li> 
			<li>Add anything to your &quot;Inbox&quot; note.</li> 
			<li>Restart Obsidian. You <i>should</i> get a notification, because your
				&quot;Inbox&quot; note no longer matches what you set it to when you ran the
				&quot;Set inbox note&quot; command.</li>`;
    },
    m(target, anchor) {
      insert(target, ol, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_if_block_6(ctx) {
  let ol;
  let li0;
  let t3;
  let li1;
  let t4;
  let t5_value = ctx[1].inboxNotePath + "";
  let t5;
  let t6;
  let t7;
  let li2;
  return {
    c() {
      ol = element("ol");
      li0 = element("li");
      li0.innerHTML = `Restart Obsidian. You should <i>not</i> get a notification, since
				your Inbox note hasn&#39;t been updated externally.`;
      t3 = space();
      li1 = element("li");
      t4 = text('Close Obsidian, and add or remove some content to your Inbox\n				note (located at "');
      t5 = text(t5_value);
      t6 = text('").');
      t7 = space();
      li2 = element("li");
      li2.innerHTML = `Open Obsidian. You <i>should</i> get a notification, because your
				&quot;Inbox&quot; note was changed outside of Obsidian.`;
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      append(ol, li0);
      append(ol, t3);
      append(ol, li1);
      append(li1, t4);
      append(li1, t5);
      append(li1, t6);
      append(ol, t7);
      append(ol, li2);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t5_value !== (t5_value = ctx2[1].inboxNotePath + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_if_block_4(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      li.textContent = "Set the default state of your inbox note. For example, if your\n				note should just have a heading in it when you don't want a\n				notification, add that heading to your note.";
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_if_block_12(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Back";
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", store_default.walkthrough.back);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Close";
      attr(button, "class", "flex ml-auto svelte-ys9x1z");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block3(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Next";
      attr(button, "class", "flex ml-auto svelte-ys9x1z");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", store_default.walkthrough.next);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment11(ctx) {
  let h1;
  let t1;
  let h2;
  let t2;
  let t3;
  let t4;
  let current_block_type_index;
  let if_block0;
  let t5;
  let div;
  let t6;
  let current;
  const if_block_creators = [create_if_block_2, create_if_block_3, create_if_block_5, create_if_block_8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].walkthroughStatus === "setCompareType")
      return 0;
    if (ctx2[1].walkthroughStatus === "runSetInboxNoteCommand")
      return 1;
    if (ctx2[1].walkthroughStatus === "restartObsidian")
      return 2;
    if (ctx2[1].walkthroughStatus === "completed")
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = ctx[1].walkthroughStatus !== WALKTHROUGH_STATUS_OPTIONS[1] && create_if_block_12(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[1].walkthroughStatus !== WALKTHROUGH_STATUS_OPTIONS[WALKTHROUGH_STATUS_OPTIONS.length - 1])
      return create_if_block3;
    return create_else_block;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block2 = current_block_type(ctx);
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Obsidian Inbox Walkthrough";
      t1 = space();
      h2 = element("h2");
      t2 = text("Step ");
      t3 = text(ctx[0]);
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      div = element("div");
      if (if_block1)
        if_block1.c();
      t6 = space();
      if_block2.c();
      attr(div, "class", "flex svelte-ys9x1z");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      insert(target, t1, anchor);
      insert(target, h2, anchor);
      append(h2, t2);
      append(h2, t3);
      insert(target, t4, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, t5, anchor);
      insert(target, div, anchor);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t6);
      if_block2.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1)
        set_data(t3, ctx2[0]);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(t5.parentNode, t5);
        } else {
          if_block0 = null;
        }
      }
      if (ctx2[1].walkthroughStatus !== WALKTHROUGH_STATUS_OPTIONS[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          if_block1.m(div, t6);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div, null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(h2);
      if (detaching)
        detach(t4);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div);
      if (if_block1)
        if_block1.d();
      if_block2.d();
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let $currentWalkthroughStep;
  let $store;
  component_subscribe($$self, currentWalkthroughStep, ($$value) => $$invalidate(0, $currentWalkthroughStep = $$value));
  component_subscribe($$self, store_default, ($$value) => $$invalidate(1, $store = $$value));
  let { closeWalthroughView } = $$props;
  function handleCloseWalkthrough() {
    closeWalthroughView();
    store_default.walkthrough.complete();
  }
  const change_handler = ({ detail }) => {
    set_store_value(store_default, $store.compareType = detail, $store);
  };
  $$self.$$set = ($$props2) => {
    if ("closeWalthroughView" in $$props2)
      $$invalidate(3, closeWalthroughView = $$props2.closeWalthroughView);
  };
  return [
    $currentWalkthroughStep,
    $store,
    handleCloseWalkthrough,
    closeWalthroughView,
    change_handler
  ];
}
var WalkthroughView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, { closeWalthroughView: 3 }, add_css6);
  }
};
var WalkthroughView_default = WalkthroughView;

// src/walkthrough/WalkthroughView.ts
var VIEW_TYPE_WALKTHROUGH = "inbox-walkthrough-view";
var InboxWalkthroughView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_WALKTHROUGH;
  }
  getDisplayText() {
    return "Inbox Walkthrough";
  }
  getIcon() {
    return "info";
  }
  async onOpen() {
    this.component = new WalkthroughView_default({
      target: this.contentEl,
      props: {
        closeWalthroughView: () => this.closeWalkthroughView()
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
  closeWalkthroughView() {
    this.plugin.app.workspace.detachLeavesOfType(VIEW_TYPE_WALKTHROUGH);
  }
};

// src/workspace-helpers.ts
var import_obsidian5 = require("obsidian");
function findMarkdownLeavesMatchingPath(workspace, path) {
  const results = [];
  workspace.iterateAllLeaves((leaf) => {
    var _a;
    if (leaf.view instanceof import_obsidian5.MarkdownView) {
      const leafFilePath = (_a = leaf.getViewState().state) == null ? void 0 : _a.file;
      if (leafFilePath && leafFilePath === path) {
        results.push(leaf);
      }
    }
  });
  return results;
}

// src/main.ts
var InboxPlugin = class extends import_obsidian6.Plugin {
  async onload() {
    this.hasPerformedCheck = false;
    await this.loadSettings();
    this.register(store_default.subscribe(async (settings) => {
      this.settings = settings;
      await this.saveSettings();
    }));
    this.registerView(VIEW_TYPE_WALKTHROUGH, (leaf) => new InboxWalkthroughView(leaf, this));
    this.addCommand({
      id: "set-inbox-note",
      name: "Set inbox note",
      checkCallback: (checking) => {
        const { activeEditor: fileInfo } = app.workspace;
        if (!fileInfo || !fileInfo.file || !fileInfo.editor) {
          return false;
        }
        if (checking) {
          return true;
        }
        this.setInboxNote(fileInfo);
      }
    });
    this.registerEvent(this.app.metadataCache.on("changed", async (file, data, cache) => {
      if (this.hasPerformedCheck && file.basename === this.settings.inboxNotePath) {
        this.settings.inboxNoteContents = data.trim();
        await this.saveSettings();
      }
    }));
    this.addSettingTab(new SettingsTab2(this.app, this));
    this.app.workspace.onLayoutReady(async () => {
      if (this.settings.walkthroughStatus === "unstarted") {
        store_default.walkthrough.reset();
        this.ensureWalkthroughViewExists();
      } else {
        await this.notifyIfInboxNeedsProcessing();
      }
    });
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_WALKTHROUGH);
    this.hasPerformedCheck = false;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.settings = migrateSettings(this.settings);
    store_default.set(this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  ensureWalkthroughViewExists(active = false) {
    const { workspace } = this.app;
    let leaf;
    const existingPluginLeaves = workspace.getLeavesOfType(VIEW_TYPE_WALKTHROUGH);
    if (existingPluginLeaves.length > 0) {
      leaf = existingPluginLeaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      workspace.revealLeaf(leaf);
      leaf.setViewState({ type: VIEW_TYPE_WALKTHROUGH });
    }
    if (active) {
      workspace.setActiveLeaf(leaf);
    }
  }
  getIsWalkthroughViewOpen() {
    return this.app.workspace.getLeavesOfType(VIEW_TYPE_WALKTHROUGH).length > 0;
  }
  async notifyIfInboxNeedsProcessing() {
    var _a;
    if (!this.settings.inboxNotePath) {
      return;
    }
    const inboxNote = this.app.vault.getAbstractFileByPath(this.settings.inboxNotePath);
    if (!inboxNote || !(inboxNote instanceof import_obsidian6.TFile)) {
      new ErrorNotice(`Failed to find inbox note at path ${inboxNote}.`);
      return;
    }
    const contents = (await this.app.vault.read(inboxNote)).trim();
    let shouldNotify = false;
    switch (this.settings.compareType) {
      case "compareToBase":
        shouldNotify = contents !== this.settings.inboxNoteBaseContents.trim();
        break;
      case "compareToLastTracked":
        shouldNotify = contents !== this.settings.inboxNoteContents.trim();
        break;
      default:
        break;
    }
    if (shouldNotify) {
      const baseMessage = `You have data to process in ${this.settings.inboxNotePath}`;
      const message = import_obsidian6.Platform.isDesktop ? `${baseMessage}
Click to dismiss, or right click to view inbox note.` : `${baseMessage}
Click to dismiss.`;
      const notice = new InfoNotice(message, (_a = this.settings.noticeDurationSeconds) != null ? _a : void 0);
      if (import_obsidian6.Platform.isDesktop) {
        notice.noticeEl.oncontextmenu = () => {
          this.openInboxNote();
          notice.hide();
        };
      }
    }
    this.hasPerformedCheck = true;
    this.settings.inboxNoteContents = contents;
    await this.saveSettings();
  }
  openInboxNote() {
    const inboxNoteLeaves = findMarkdownLeavesMatchingPath(this.app.workspace, this.settings.inboxNotePath);
    if (inboxNoteLeaves.some(Boolean)) {
      this.app.workspace.setActiveLeaf(inboxNoteLeaves[0], {
        focus: true
      });
      return;
    }
    const inboxNote = this.app.vault.getAbstractFileByPath(this.settings.inboxNotePath);
    if (inboxNote instanceof import_obsidian6.TFile) {
      const leaf = this.app.workspace.getLeaf(true);
      leaf.openFile(inboxNote);
      return;
    }
    new ErrorNotice(`Failed to find inbox note at path ${inboxNote}.`);
  }
  setInboxNote(fileInfo) {
    if (!fileInfo.file || !fileInfo.editor) {
      new ErrorNotice("Failed to set inbox note, no editor detected.");
      return;
    }
    this.settings.inboxNotePath = fileInfo.file.path;
    if (this.settings.compareType === "compareToBase") {
      this.settings.inboxNoteBaseContents = getValueFromMarkdownFileInfo(fileInfo);
    }
    if (this.settings.compareType === "compareToLastTracked") {
      this.settings.inboxNoteContents = getValueFromMarkdownFileInfo(fileInfo).trim();
    }
    if (this.getIsWalkthroughViewOpen() && this.settings.walkthroughStatus === "runSetInboxNoteCommand") {
      store_default.walkthrough.next();
    }
    this.saveSettings();
    let message = `Inbox note path set to ${this.settings.inboxNotePath}`;
    if (this.settings.compareType === "compareToBase") {
      message += `
Inbox note base contents set to
${this.settings.inboxNoteBaseContents || "<blank>"}`;
    }
    new InfoNotice(message);
  }
};
